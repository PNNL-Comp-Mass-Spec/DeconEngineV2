// Written by Navdeep Jaitly for the Department of Energy (PNNL, Richland, WA)
// Copyright 2006, Battelle Memorial Institute
// E-mail: navdeep.jaitly@pnl.gov
// Website: http://ncrr.pnl.gov/software
// -------------------------------------------------------------------------------
// 
// Licensed under the Apache License, Version 2.0; you may not use this file except
// in compliance with the License.  You may obtain a copy of the License at 
// http://www.apache.org/licenses/LICENSE-2.0

#pragma once
#include "../Utilities/Interpolation.h"
#include "../PeakProcessor/PeakData.h"

namespace Engine
{
	namespace ChargeDetermination
	{
		class  AutoCorrelationChargeDetermine
		{
	#pragma warning(disable: 4251)
			//! helps in quick searching for a spcific m/z value in the input vectors. 
			PeakProcessing::PeakIndex<double> mobj_peak_index ; 
			//! std::vector to temporarily store part of the raw data for which we want to do calculate the autocorrelation.
			/*!
				\remarks When performing autocorrelation to determine the charge we extract the points around the peak of interest
				and calculate the autocorrelations for that stretch only. This variable stores the m/z values of these 
				points of interest. 
				\sa AutoCorrelationChargeDetermine::mvect_Y
			*/
			std::vector<double> mvect_X ; 
			//! std::vector to temporarily store part of the raw data for which we want to do calculate the autocorrelation.
			/*!
				\remarks When performing autocorrelation to determine the charge we extract the points around the peak of interest
				and calculate the autocorrelations for that stretch only. This variable stores the intensity values of these 
				points of interest. 
				\sa AutoCorrelationChargeDetermine::mvect_X
			*/
			std::vector<double> mvect_Y ; 
			//! std::vector to store the interpolated intensities of the region on which we performed the cubic spline interpolation.
			std::vector<double> mvect_Iv ; 
			//! std::vector to store the autocorrelation values at the points in the region.
			std::vector<double> mvect_autocorrelation_scores ; 
			//! std::vector to temporarily store charge list. These charges are calculated at peak values of autocorrelation.
			std::vector<short> mvect_charge_list ; 
	#pragma warning(default: 4251)
			//! varaible to help us perform spline interpolation.
			Utilities::Interpolation mobj_interpolation ; 
			short mshort_max_charge ; 

		public:
			int mint_total_cs_time ;
			int mint_autocorrelation_time ; 
			int mint_spline_time ; 

			//! default constructor.
			AutoCorrelationChargeDetermine(void);
			//! destructor.
			~AutoCorrelationChargeDetermine(void);
			//! Gets the charge state (determined by AutoCorrelation algorithm) for a peak in some data.
			/*!
				\param pk is the peak whose charge we want to detect.
				\param peak_data is the PeakData object containing raw data, peaks, etc which are used in the process.
				\returns Returns the charge of the feature.
			*/
			short GetChargeState(PeakProcessing::Peak &pk, PeakProcessing::PeakData &peak_data, bool debug) ; 
			//! Calculate the autocorrelation values for the an input.
			/*!
				\param Iv function for which we want to calculate autocorrelation. 
				\param Ov autocorrelation values. Ov[i] is the autocorrelation at distance i.
				\note It is assumed that the x values for this function are equally spaced.
			*/
			void ACss(std::vector<double> &Iv, std::vector<double> &Ov) ; 
			//! Gets the best autocorrelation score, and the charge state corresponding to the distance.
			/*!
				\param minMZ minimum m/z value of the chosen range
				\param maxMZ maximum m/z value of the chose range
				\param minN the number of points at the start that we will skip in looking for high autocorrelation scores.
				\param ac_scores std::vector of autocorrelation scores.
				\param maxCS maximum charge state that we are looking for.
				\param best_ac returns the best autocorrelation score. 
				\param bestCS returns the charge state at the best autocorrelation score distance.
			*/
			void HighestCSPeak(double minMZ, double maxMZ, int minN, std::vector<double> &ac_scores, short maxCS, double &best_ac, short &bestCS) ; 
			//! Generates the list of possible charge states from the autocorrelation scores and the best score. 
			/*!
				\param minMZ minimum mz.
				\param maxMZ maximum mz.
				\param minN the number of points at the start that we will skip in looking for high autocorrelation scores.
				\param ac_scores std::vector of autocorrelation scores.
				\param maxCS maximum charge state to look for.
				\param best_ac_score best autocorrelation score.
				\param vect_CS std::vector of charge states generated.
				\remarks The list of charge states is generated by finding out what are the locally maximum autocorrelation scores and using the corresponding
					distance to figure out the charge. Obviously, a high autocorrleation score at 0.48 implies a charge of 2, at at 0.31 implies charge 3 etc.
					Keep in mind that the autocorrelation score is not going to be perfectly at 0.5, or 0.33 etc, but approximately at those points.
			*/
			void GenerateCSList(double minMZ, double maxMZ, int minN, std::vector<double> &ac_scores, double maxCS, double best_ac_score, std::vector<short> &vect_CS) ; 

		};
	}
}